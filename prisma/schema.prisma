generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId], map: "Account_userId_fkey")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Session_userId_fkey")
}

model User {
  id            String              @id @unique(map: "user_Id") @default(cuid())
  name          String?
  email         String?             @unique
  emailVerified DateTime?
  password      String?             @db.VarChar(999)
  image         String?
  last_online   DateTime            @default(now()) @db.Timestamp(0)
  last_action   String?
  level         Int                 @default(1)
  experience    Float               @default(0)
  gold          Decimal             @default(0) @db.Decimal(10, 2)
  accounts      Account[]
  equipment     Equipment?
  inventory     Inventory?
  sessions      Session[]
  user_skills   user_skills[]
  baseStats     CharacterBaseStat[]
  xpMultipliers XpMultiplier[]
  userItems     UserItem[]
  
  @@index([level])
  @@index([experience])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Base_Items {
  id          Int    @id @default(autoincrement())
  name        String @db.Text
  description String @db.Text
}

model Base_Items_M {
  id           Int     @id @default(autoincrement())
  name         String? @db.VarChar(255)
  min_ad       Float?  @db.Float
  max_ad       Float?  @db.Float
  attack_speed Float?  @db.Float
  armor        Float?  @db.Float
  sprite       String? @db.Text
}

model Example {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime
}

enum ItemRarity {
  WORTHLESS
  BROKEN
  COMMON
  UNCOMMON
  RARE
  EXQUISITE
  EPIC
  ELITE
  UNIQUE
  LEGENDARY
  MYTHIC
  DIVINE
}

enum StatType {
  // Offensive Stats
  PHYSICAL_DAMAGE_MIN
  PHYSICAL_DAMAGE_MAX
  MAGIC_DAMAGE_MIN
  MAGIC_DAMAGE_MAX
  CRITICAL_CHANCE
  CRITICAL_DAMAGE
  ATTACK_SPEED
  ACCURACY

  // Defensive Stats
  ARMOR
  MAGIC_RESIST
  EVASION_MELEE
  EVASION_RANGED
  EVASION_MAGIC
  BLOCK_CHANCE

  // Resistances
  FIRE_RESIST
  COLD_RESIST
  LIGHTNING_RESIST
  POISON_RESIST

  // Character Resources
  HEALTH
  MANA
  HEALTH_REGEN
  MANA_REGEN

  // Special Stats
  PRAYER_POINTS
  MOVEMENT_SPEED
  LUCK
  GOLD_FIND
  EXPERIENCE_GAIN
  LIFESTEAL
  THORNS
  CARRYING_CAPACITY
}

model Item {
  id      Int        @id @default(autoincrement())
  name    String
  price   Float
  sprite  String
  equipTo String?
  rarity  ItemRarity @default(COMMON)

  // Denormalized columns for fast marketplace queries
  minPhysicalDamage Float? @default(0)
  maxPhysicalDamage Float? @default(0)
  minMagicDamage    Float? @default(0)
  maxMagicDamage    Float? @default(0)
  armor             Float? @default(0)
  requiredLevel     Int?   @default(1)

  // Relationships
  stats            ItemStat[]
  statProgressions ItemStatProgression[] // Defines stats at each rarity tier
  userItems        UserItem[]            // Item instances owned by players

  @@index([minPhysicalDamage])
  @@index([maxPhysicalDamage])
  @@index([minMagicDamage])
  @@index([armor])
  @@index([requiredLevel])
  @@index([rarity])
}

model ItemStat {
  id       Int      @id @default(autoincrement())
  itemId   Int
  statType StatType
  value    Float

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([itemId, statType])
  @@index([statType, value])
}

// Stat progression - defines which stats unlock at which rarity
// This ensures all items of the same type and rarity have identical stats
model ItemStatProgression {
  id              Int        @id @default(autoincrement())
  itemId          Int
  statType        StatType
  baseValue       Float      // Base value at COMMON rarity
  unlocksAtRarity ItemRarity // When this stat becomes available
  
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
  
  @@unique([itemId, statType])
  @@index([itemId, unlocksAtRarity])
}

// ============================================
// USER ITEM INSTANCES
// ============================================

enum ItemStatus {
  IN_INVENTORY   // In player's inventory
  EQUIPPED       // Currently equipped
  LISTED         // On marketplace
  SOLD           // Sold (historical record)
  DELETED        // Deleted/destroyed
}

// Player-owned item instances
// Each player has their own copy with unique rarity and stats
model UserItem {
  id             Int           @id @default(autoincrement())
  userId         String
  itemId         Int           // Reference to Item template
  rarity         ItemRarity    @default(COMMON)
  
  // Item location/status
  status         ItemStatus    @default(IN_INVENTORY)
  
  // Marketplace data (only when status = LISTED)
  listedPrice    Float?        // Listing price in gold
  listedAt       DateTime?     // When listed
  
  // Metadata
  acquiredAt     DateTime      @default(now())
  isTradeable    Boolean       @default(true)
  
  // Relationships
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  itemTemplate   Item          @relation(fields: [itemId], references: [id], onDelete: Cascade)
  stats          UserItemStat[]
  
  @@index([userId])
  @@index([itemId])
  @@index([status])
  @@index([status, listedAt])
  @@index([userId, status])
}

// Stats for each user item instance
model UserItemStat {
  id         Int      @id @default(autoincrement())
  userItemId Int
  statType   StatType
  value      Float
  
  userItem   UserItem @relation(fields: [userItemId], references: [id], onDelete: Cascade)
  
  @@unique([userItemId, statType])
  @@index([userItemId])
}



model CharacterBaseStat {
  id       Int      @id @default(autoincrement())
  userId   String
  statType StatType
  value    Float

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, statType])
  @@index([userId])
}

model Inventory {
  id           Int    @id @default(autoincrement())
  maxSlots     Int    @default(25)
  userId       String @unique
  slots        Json   // Stores { slotIndex: number, item: { id: number } | null }[]
  deleteSlotId Int?   // UserItem ID in the delete slot (nullable)
  User         User   @relation(fields: [userId], references: [id])
}

model Equipment {
  id        Int    @id @default(autoincrement())
  userId    String @unique
  
  // UserItem instance IDs (player-specific items with unique rarity/stats)
  headItemId      Int?
  chestItemId     Int?
  beltItemId      Int?
  legsItemId      Int?
  bootsItemId     Int?
  necklaceItemId  Int?
  ring1ItemId     Int?
  ring2ItemId     Int?
  amuletItemId    Int?
  shouldersItemId Int?
  armsItemId      Int?
  glovesItemId    Int?
  backpackItemId  Int?
  weaponItemId    Int?
  
  User      User   @relation(fields: [userId], references: [id])
}

model Modifiers {
  id        Int    @id @default(autoincrement())
  name      String @db.VarChar(255)
  code      String @db.VarChar(255)
  mod_range String @db.VarChar(255)
}

model skills {
  skill_id    Int           @id @default(autoincrement())
  skill_name  String        @unique(map: "skill_name")
  description String?       @db.Text
  user_skills user_skills[]
}

model user_skills {
  user_skill_id Int      @id @default(autoincrement())
  user_id       String
  skill_id      Int
  level         Int      @default(1)
  current_xp    Int      @default(0)
  updated_at    DateTime @default(now()) @db.Timestamp(0)
  skills        skills   @relation(fields: [skill_id], references: [skill_id], onUpdate: Restrict, map: "user_skills_ibfk_1")
  User          User     @relation(fields: [user_id], references: [id], onUpdate: Restrict, map: "user_skills_ibfk_2")

  @@unique([user_id, skill_id], map: "user_id")
  @@index([skill_id], map: "skill_id")
}

// ============================================
// LEVELING SYSTEM
// ============================================

// XP Configuration - Single source of truth for XP curves
model XpConfig {
  id                    Int      @id @default(autoincrement())
  configName            String   @unique // e.g., "default", "season1", "hardmode"
  isActive              Boolean  @default(false) // Only one config can be active
  
  // Base XP formula parameters
  baseXp                Float    @default(100)     // XP needed for level 2
  exponentMultiplier    Float    @default(1.5)     // Controls curve steepness
  levelMultiplier       Float    @default(1.0)     // Additional scaling per level
  
  // Level brackets with different difficulty
  easyLevelCap          Int      @default(5)       // Levels 1-5: easy
  easyMultiplier        Float    @default(0.8)     // 80% of normal XP
  
  normalLevelCap        Int      @default(15)      // Levels 6-15: normal
  normalMultiplier      Float    @default(1.0)     // 100% of normal XP
  
  hardLevelCap          Int      @default(30)      // Levels 16-30: hard
  hardMultiplier        Float    @default(1.3)     // 130% of normal XP
  
  veryHardLevelCap      Int      @default(50)      // Levels 31-50: very hard
  veryHardMultiplier    Float    @default(1.8)     // 180% of normal XP
  
  extremeLevelCap       Int      @default(62)      // Levels 51-62: extreme
  extremeMultiplier     Float    @default(3.0)     // 300% of normal XP
  
  // Soft cap system (nearly impossible to level past this)
  softCapLevel          Int      @default(62)
  softCapMultiplier     Float    @default(10.0)    // 1000% of normal XP (almost impossible)
  
  // Hard cap (absolute maximum level)
  hardCapLevel          Int      @default(70)
  
  // Seasonal/event settings
  seasonalBonus         Float    @default(0)       // Global XP bonus (0 = none, 0.1 = 10% more)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([isActive])
}

// XP Multipliers (temporary boosts from items, events, etc.)
model XpMultiplier {
  id                Int      @id @default(autoincrement())
  userId            String
  
  name              String                        // e.g., "XP Boost Card", "Weekend Event"
  multiplier        Float                         // 1.1 = 10% more XP, 2.0 = 100% more XP
  
  // Optional: specific action types
  actionType        XpActionType?                 // null = applies to all actions
  
  // Duration
  expiresAt         DateTime?                     // null = permanent until manually removed
  usesRemaining     Int?                          // null = unlimited uses
  
  isActive          Boolean  @default(true)
  stackable         Boolean  @default(true)       // Can stack with other multipliers
  
  createdAt         DateTime @default(now())
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isActive, expiresAt])
  @@index([expiresAt])
}

// Types of actions that give XP
enum XpActionType {
  COMBAT              // Killing monsters
  QUEST               // Completing quests
  CRAFTING            // Crafting items
  GATHERING           // Mining, fishing, woodcutting, etc.
  SKILL               // Training skills
  EXPLORATION         // Discovering new areas
  DUNGEON             // Completing dungeons
  BOSS                // Defeating bosses
  PVP                 // Player vs Player
  TRADE               // Trading with other players
  ACHIEVEMENT         // Unlocking achievements
  DAILY               // Daily activities
  EVENT               // Special events
}

// ============================================
// ITEM RARITY SYSTEM
// ============================================

// Rarity multipliers configuration
model RarityConfig {
  id                  Int        @id @default(autoincrement())
  rarity              ItemRarity @unique
  
  // Stat multiplier (e.g., 1.0 = 100%, 2.0 = 200%)
  statMultiplier      Float      @default(1.0)
  
  // Max number of stats this rarity can have
  minStats            Int        @default(1)
  maxStats            Int        @default(3)
  
  // Additional bonus stats for higher rarities
  bonusStatChance     Float      @default(0)  // 0-1 (0% to 100% chance for extra stat)
  
  // Visual/Display
  color               String     @default("#ffffff")
  displayName         String
  sortOrder           Int        @default(0)  // For sorting in UI
  
  // Upgrade system
  upgradeEnabled      Boolean    @default(true)
  nextRarity          ItemRarity?
  upgradeCost         Int?       // Cost to upgrade to next rarity
  
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  
  @@index([rarity])
}

// XP Transaction Log (for debugging and analytics)
model XpTransaction {
  id                Int              @id @default(autoincrement())
  userId            String
  
  amount            Float                         // Base XP amount
  finalAmount       Float                         // After all multipliers
  actionType        XpActionType
  
  // Multipliers applied
  baseMultiplier    Float            @default(1.0)
  itemMultipliers   Json?                         // Array of applied item multipliers
  eventMultipliers  Json?                         // Array of applied event multipliers
  
  // Level context
  levelBefore       Int
  levelAfter        Int
  experienceBefore  Float
  experienceAfter   Float
  
  // Optional context
  description       String?                       // e.g., "Killed Goblin", "Completed Quest: Save the Village"
  metadata          Json?                         // Any additional data
  
  createdAt         DateTime         @default(now())
  
  @@index([userId, createdAt])
  @@index([actionType])
  @@index([createdAt])
}
